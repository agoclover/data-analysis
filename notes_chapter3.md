# 3. NumPy库

笔记主要内容来自对Fabio Nelli所著的《Python数据分析实战》。

## 3.1 介绍
NumPy（以下简写为numpy）是Python（以下简写为python）科学计算的扩展包，在计算多维数组和大型数组方面使用广泛。

同时，numpy提供多个函数来实现高级数学运算。
## 3.3 ndarray：numpy库的心脏
基本元素见py文件_3.3.0.
### 3.3.1 创建数组
`array()`函数可以创建单层或嵌套的列表、元组或其组合。
### 3.3.2 数据类型
#### dtype一览表
[链接](https://www.runoob.com/numpy/numpy-dtype.html)
### 3.3.3 dtype
定义一个dtype类型的数组
`f = np.array([[1, 2, 3], [4, 5, 6]], dtype=complex`

**dtype = '<U1'**

'<'表示字节顺序，小端（最小有效字节存储在最小地址中）；

'U'表示Unicode，数据类型；

'1'表示元素位长，数据大小；
### 3.3.4 自带数组创建方法
`numpy.zeros((3, 3))` 由shape参数指定维数的元素为0的矩阵

`numpy.ones((3, 3))` 由shape参数指定维数的元素为1的矩阵

`numpy.arange(0, 6, 0.6)` 包含一个数值序列的数组，range()函数只可以使用整数作为步长

`numpy.arange(0, 12).reshape(3, 4)` 包含一个数值序列的reshape指定型的矩阵

`numpy.linspace(0, 10, 5)` 指定想把开头和结尾两个数字指定的范围分成几个部分

`numpy.random.random(3)`或`numpy.random.random((3, 3))` 生成随机数组或矩阵
## 3.4 基本操作
### 3.4.1 算术运算符

### 3.4.2 矩阵积

### 3.4.3 自增和自减运算符

### 3.4.4 通用函数

### 3.4.5 聚合函数
## 3.5 索引机制、切片和迭代方法

### 3.5.1  索引机制

```python
# 列表情况
>>> a = np.arange(10, 16)
>>> a
array([10, 11, 12, 13, 14, 15])
# 使用正数索引
>>> a[4]
14
# 使用负数索引
>>> a[-1]
15
# 同时索引多个元素
>>> a[[1,3,4]]
array([11, 13, 14])
# 矩阵情况
>>> A = np.arange(10, 19).reshape((3,3))
>>> A
array([[10, 11, 12],
       [13, 14, 15],
       [16, 17, 18]])
# 使用方括号取出1个元素
>>> A[1, 2]
15
# 使用方括号取出多个元素
>>> A[[1, 2], [2, 0]]
array([15, 16])
```

### 3.5.2 切片操作

抽取数组的一部分元素生成新数组。

对numpy数组进行切片操作得到的数组则是指向相同缓冲区的视图。

```python
# 列表切片
# [开始位置:结束为止:步长]
>>> a[1:4:2]
array([11, 13])
# 矩阵切片
# 抽取某行
>>> A[0, :]
array([10, 11, 12])
# 抽取某列
>>> A[:, 1]
array([11, 14, 17])
# 抽取子矩阵
>>> A[0:2, 0:2]
array([[10, 11],
       [13, 14]])
# 抽取的行或列的索引不连续，可以将索引放到数组中
>>> A[[0,2], 0:2]
array([[10, 11],
       [16, 17]])
```

### 3.5.3 数组迭代

```python
# for循环遍历
# 一维数组遍历
>>> for i in a:
...     print(i)
...
0
1
2
3
# 矩阵行遍历
>>> for item in A:
...     print(item)
... 
[10 11 12]
[13 14 15]
[16 17 18]
# 矩阵元素遍历
>>> for item in A.flat:
...     print(item)
...    
10
11
12
13
14
15
16
17
18
# numpy.apply_along_axis(func1d, axis, arr), func1d为聚合函数，axis=0代表按列/1代表按行，arr为数组。
>>> np.apply_along_axis(np.mean, axis=0, arr=A)
array([13., 14., 15.])
# func1d为自定义通用函数
>>>def foo(x):
...    return x // 2
...
>>>np.apply_along_axis(foo, 0, C)
array([[5, 5, 6],
       [6, 7, 7],
       [8, 8, 9]])
```

## 3.6 条件和布尔数组

```python
>>>A = np.random.random((4,4))
>>>A
array([[0.22217827, 0.5720727 , 0.03565431, 0.53681422],
       [0.1813633 , 0.75326472, 0.84861839, 0.37513582],
       [0.93907292, 0.86581792, 0.77825129, 0.62063509],
       [0.54120821, 0.79230328, 0.13948262, 0.93518623]])
# 有条件的布尔数组
>>>A < 0.5
array([[ True, False,  True, False],
       [ True, False, False,  True],
       [False, False, False, False],
       [False, False,  True, False]])
# 选取一部分元素，条件表达式放置于括号中
>>>A[A < 0.5]
array([0.22217827, 0.03565431, 0.1813633 , 0.37513582, 0.13948262])
```

## 3.7 形状变换

```python
# reshape()函数把一维数组转换为矩阵，返回一个新数组
>>>a = np.random.random(12)
>>>a
array([0.70858536, 0.20215749, 0.24585743, 0.93775824, 0.61781872,
       0.93142929, 0.08375719, 0.73551734, 0.98193623, 0.566584  ,
       0.53227751, 0.19651117])
>>>A = a.reshape(3, 4)
>>>A
array([[0.70858536, 0.20215749, 0.24585743, 0.93775824],
       [0.61781872, 0.93142929, 0.08375719, 0.73551734],
       [0.98193623, 0.566584  , 0.53227751, 0.19651117]])
# 把表示新形状的元组直接赋值给数组的shape属性，以改变数组的形状
>>>a.shape = (3, 4)
>>>a
array([[0.70858536, 0.20215749, 0.24585743, 0.93775824],
       [0.61781872, 0.93142929, 0.08375719, 0.73551734],
       [0.98193623, 0.566584  , 0.53227751, 0.19651117]])
# ravel()函数可以返回一个新的一维数组, 需 a = a.ravel()才能更改a
>>>a.ravel()
array([0.70858536, 0.20215749, 0.24585743, 0.93775824, 0.61781872,
       0.93142929, 0.08375719, 0.73551734, 0.98193623, 0.566584  ,
       0.53227751, 0.19651117])
>>>a
array([[0.70858536, 0.20215749, 0.24585743, 0.93775824],
       [0.61781872, 0.93142929, 0.08375719, 0.73551734],
       [0.98193623, 0.566584  , 0.53227751, 0.19651117]])
# 直接更改shape属性，以从矩阵变为一维数组
>>>a.shape = (12)
>>>a
array([0.70858536, 0.20215749, 0.24585743, 0.93775824, 0.61781872,
       0.93142929, 0.08375719, 0.73551734, 0.98193623, 0.566584  ,
       0.53227751, 0.19651117])
# transpose()函数返回一个A的转置矩阵，新矩阵
>>>A.transpose()
array([[0.70858536, 0.61781872, 0.98193623],
       [0.20215749, 0.93142929, 0.566584  ],
       [0.24585743, 0.08375719, 0.53227751],
       [0.93775824, 0.73551734, 0.19651117]])
>>>A
array([[0.70858536, 0.20215749, 0.24585743, 0.93775824],
       [0.61781872, 0.93142929, 0.08375719, 0.73551734],
       [0.98193623, 0.566584  , 0.53227751, 0.19651117]])
```

## 3.8 数组操作

通过连接和切分已有数组创建新数组。

### 3.8.1 连接数组

```python
# 通过vstack()：纵向入栈和hstack()：横向入栈进行栈操作，返回栈
>>>A = np.ones((3,3))
>>>B = np.zeros((3,3))
>>>np.vstack((A,B))
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])
>>>np.hstack((B, A))
array([[0., 0., 0., 1., 1., 1.],
       [0., 0., 0., 1., 1., 1.],
       [0., 0., 0., 1., 1., 1.]])
# column_stack()和row_stack()对数组进行栈操作，返回栈
>>>a = np.array([0, 1, 2])
>>>b = np.array([3, 4, 5])
>>>c = np.array([6, 7, 8])
>>>np.column_stack((a, b, c))
array([[0, 3, 6],
       [1, 4, 7],
       [2, 5, 8]])
>>>np.row_stack((a, b ,c))
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
```

### 3.8.2 数组切分

```python
>>>A = np.arange(16).reshape((4,4))
>>>A
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
# 行代表从左到右对称拆分hsplit(,)
>>>[B, C] = np.hsplit(A, 2)
>>>B
array([[ 0,  1],
       [ 4,  5],
       [ 8,  9],
       [12, 13]])
>>>C
array([[ 2,  3],
       [ 6,  7],
       [10, 11],
       [14, 15]])
# 列代表从上到下对称拆分vsplit(,)
>>>[D, E] = np.vsplit(A, 2)
>>>D
array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
>>>E
array([[ 8,  9, 10, 11],
       [12, 13, 14, 15]])
# split(arr, 形状, axis)，axis=1，列索引；axis=0，行索引。
>>>[A1, A2, A3] = np.split(A, [1,3], axis=1)
>>>A1
array([[ 0],
       [ 4],
       [ 8],
       [12]])
>>>A2
array([[ 1,  2],
       [ 5,  6],
       [ 9, 10],
       [13, 14]])
>>>A3
array([[ 3],
       [ 7],
       [11],
       [15]])
```



## 3.9 常用概念

### 3.9.1 对象的副本或视图

**副本**：深拷贝，不同对象；**视图**：浅拷贝，同一对象

python列表切片操作得到的是副本。

```python
# 赋值操作是视图，赋值运算不会为数组中的任何元素创建副本
>>>a = np.array([1, 2, 3, 4])
>>>b = a
>>>b
array([1, 2, 3, 4])
>>>a[2] = 0
>>>b
array([1, 2, 0, 4])
# 数组切片操作返回的对象只是原数组的视图
>>>c = a[0:2]
>>>c
array([1, 2])
>>>a[0] = 0
>>>c
array([0, 2])
```

### 3.9.2 向量化

向量化和广播是numpy内部实现的基础。向量化，编写代码时无需使用显式循环，使代码更简洁，可读性更强。

向量化使很多运算看上去更像是数学表达式，比如`a * b`即可表示数组相乘，`A * B`即可表示矩阵元素相乘(不是矩阵相乘)。

### 3.9.3 广播机制

在不同结构的数组或矩阵进行计算时，会对各arr进行填充以满足同型，从而能够计算。

```python
# 矩阵与数组，数组会以列表元素的数进行扩容
>>>A = np.arange(16).reshape((4,4))
>>>b = np.arange(4)
>>>A
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>>b
array([0, 1, 2, 3])
>>>A + b
array([[ 0,  2,  4,  6],
       [ 4,  6,  8, 10],
       [ 8, 10, 12, 14],
       [12, 14, 16, 18]])
# 两个矩阵：m为3行1列每个位置包含2个元素，n为3行2列每个位置包含1个元素。那么m和n会扩容为3，2，2，即取大的shape从而兼容，填充的值即为原矩阵对应位置的元素。
>>>m = np.arange(6).reshape(3, 1, 2)
>>>n = np.arange(6).reshape(3, 2, 1)
>>>m
array([[[0, 1]],
       [[2, 3]],
       [[4, 5]]])
>>>n
array([[[0],
        [1]],
       [[2],
        [3]],
       [[4],
        [5]]])
>>>m + n
array([[[ 0,  1],
        [ 1,  2]],
       [[ 4,  5],
        [ 5,  6]],
       [[ 8,  9],
        [ 9, 10]]])
```



## 3.10 结构化数组

NumPy支持的数值类型比Python更多。

> 数据分析过程中，经常会有多种不同数据类型同时出现，而不仅仅是期望的数值型数据，而Array只能含有一种数据类型，Numpy/pandas该如何处理呢？在C语言中经常通过结构体struct来定义不同数据类型形成结构类型，结构中的字段占据连续的内存空间，每个结构体占用的内存大小均相同，类似的Numpy可以很容易的定义结构数组。和C语言一样，在Numpy中也可以操作这些字段对这种结构数组进行操作。只要Numpy的结构和C语言中的定义相同，Numpy就可以很方便地读取C语言的结构数组的二进制数据，转换为Numpy的结构数组。
>
> 引用自[Li_Michael](https://www.jianshu.com/p/e4900fc4df57)。

### 3.10.1 数组/数据类型

1. 构造数组时：布尔值默认类型`bool`，整数默认类型是`int64`，浮点数默认是`float64`，复数默认`complex128`，不予显示。`uint_`默认为`uint64`，显示说明。

2. 当整数类型改变为`int8, int16, int32`, 浮点数类型改变为`float16, float32,`类型会显示说明`dtype=int8`，复数类型改变为`complex64`，因为非默认值，总会显示说明；`uint_`类型特殊，如1所说，总会显示说明。
3. numpy 的数值类型实际上是 `dtype` 对象的实例，并对应唯一的字符，包括 `np.bool_`，`np.int32`，`np.float32`，等等。

| 数据类型   | 描述                                                         | 是否默认显示 |
| :--------- | :----------------------------------------------------------- | ------------ |
| bool_      | 以字节存储的布尔值（True 或 False）                          | 否           |
| int_       | 默认的整数类型（和 C 的 long 一样，是 int64 或者 int32）     | 否           |
| intc       | 和 C 的 int 相同（一般为 int64 或 int32）                    | int32        |
| intp       | 用于下标的整数（和 C 的 ssize_t 相同，一般为int64 或者 int32） | 否           |
| int8       | 字节（-128 到 127）                                          | 是           |
| int16      | 整数（-32768 到 32767）                                      | 是           |
| int32      | 整数（-2147483648 到 2147483647）                            | 是           |
| int64      | 整数（-9223372036854775808 到 9223372036854775807）          | 否           |
| uint8      | 无符号整数（0 到 255）                                       | 是           |
| uint16     | 无符号整数（0 到 65535）                                     | 是           |
| uint32     | 无符号整数（0 到 4294967295）                                | 是           |
| uint64     | 无符号整数（0 到 18446744073709551615）                      | 是           |
| float_     | float64 的简写                                               | 否           |
| float16    | 半精度浮点：1位符号，5位指数，10位尾数                       | 是           |
| float32    | 单精度浮点：1位符号，8位指数，23位尾数                       | 是           |
| float64    | 双精度浮点：1位符号，11位指数，52位尾数                      | 否           |
| complex_   | complex128 的简写                                            | 否           |
| complex64  | 由两个32位浮点（实部和虚部）组成的复数                       | 是           |
| complex128 | 由两个64位浮点（实部和虚部）组成的复数                       | 否           |
| unicode_   | np.unicode_是字符串的dtype                                   | '<U_'        |

### 3.10.2 字符代码

每个**内建类型**都有一个唯一定义它的字符代码：

| 字符 | 对应类型                                                     |
| :--- | :----------------------------------------------------------- |
| b    | 布尔型                                                       |
| i    | (有符号) 整型，int8, int16, int32, int64 四种数据类型可以使用字符串 'i1', 'i2','i4','i8' 代替 |
| u    | 无符号整型 integer                                           |
| f    | 浮点型                                                       |
| c    | 复数浮点型                                                   |
| m    | timedelta（时间间隔）                                        |
| M    | datetime（日期时间）                                         |
| O    | (Python) 对象                                                |
| S, a | (byte-)字符串                                                |
| U    | Unicode                                                      |
| V    | 原始数据 (void)                                              |

### 3.10.3 数据类型对象(dtype)

数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：

- 数据的类型（整数，浮点数或者 Python 对象）
- 数据的大小（例如， 整数使用多少个字节存储）
- 数据的字节顺序（小端法或大端法）
- 在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分
- 如果数据类型是子数组，它的形状和数据类型

字节顺序是通过对数据类型预先设定"<"或">"来决定的。"<"意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。">"意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。

dtype 对象是使用以下语法构造的：

```
numpy.dtype(object, align, copy)
```

- object - 要转换为的数据类型对象
- align - 如果为 true，填充字段使其类似 C 的结构体。
- copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用

> 以上3.10.3小节内容引用自[runoob.com](https://www.runoob.com/numpy/numpy-dtype.html)

### 3.10.4 结构化数组

对数据类型对象（dtype）这个概念更深入的理解。

> 以下例1，来自[runoob.com](https://www.runoob.com/numpy/numpy-dtype.html)：

```python
# 使用标量类型
>>>dt = np.dtype(np.int32)
>>>dt
dtype('int32')
>>>print(dt)
int32
# 使用字符代码
>>>dt = np.dtype('i4')
>>>print(dt)
int32
# 字节顺序标注
>>>dt = np.dtype('<i4')
>>>print(dt)
int32
```

下面实例展示结构化数据类型的使用，类型字段和对应的实际类型将被创建。

```python
# 创建结构化数据类型
>>>dt = np.dtype([('age', np.int8)])
>>>dt
dtype([('age', 'i1')])
>>>print(dt)
[('age', 'i1')]
# 将数据类型应用于 ndarray 对象
>>>a = np.array([(10,), (20,), (30,)], dtype=dt)
>>>print(a)
[(10,) (20,) (30,)]
>>>print(a['age'])
[10 20 30]
# 定义一个结构化数据类型student，包含字符串字段name，整数字段age，浮点字段marks，并将这个dtype应用到ndarray对象。
>>>student = np.dtype([('name', 'U20'), ('age', 'i4'), ('marks', 'i4')])
>>>print(student)
[('name', '<U20'), ('age', '<i4'), ('marks', '<i4')]
>>>a = np.array([('amos', 24, 100), ('anna', 20, 101)], dtype=student)
>>>print(a)
[('amos', 24, 100) ('anna', 20, 101)]
>>>print(a['age'])
[24 20]
```

### 3.10.5 数据类型的转换

```python
# arr.astype(np.dtype)返回一个新的指定np.dtype数据类型的数组；不要直接通过arr.dtype = np.dtype来修改。dtype用于查看数据类型。
>>>arr
array([1, 2, 3, 4, 5])
>>>arr.astype(np.float)
array([1., 2., 3., 4., 5.])
>>>arr
array([1, 2, 3, 4, 5])
```

## 3.11 数组数据文件的读写

numpy提供了几个函数，可以把结果保存到文本或二进制文件中；也提供了从文件中读取数据并将其转换为数组的方法。

### 3.11.1 二进制文件的读写

Numpy 可以读写磁盘上的文本数据或二进制数据。

NumPy 为 ndarray 对象引入了一个简单的文件格式：**npy**。

npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。

常用的 IO 函数有：

- load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。
- savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。
- loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)

#### numpy.save()

numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。

```python
numpy.save(file, arr, allow_pickle=True, fix_imports=True)
```

**参数说明：**

- **file**：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。
- **arr**: 要保存的数组
- **allow_pickle**: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。
- **fix_imports**: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。

```python
>>>np.save('student.npy', a)
>>>b = np.load('student.npy')
>>>b
array([('amos', 24, 100), ('anna', 20, 101)],
      dtype=[('name', '<U20'), ('age', '<i4'), ('marks', '<i4')])
```

#### numpy.savez()

numpy.savez() 函数将多个数组保存到以 npz 为扩展名的文件中。

```python
numpy.savez(file, *args, **kwds)
```

参数说明：

- **file**：要保存的文件，扩展名为 **.npz**，如果文件路径末尾没有扩展名 **.npz**，该扩展名会被自动加上。
- **args**: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 **arr_0**, **arr_1**, …　。
- **kwds**: 要保存的数组使用关键字名称。

```python
>>>a = np.array([1, 2, 3, 4, 5])
>>>b = np.arange(0, 1, 0.1)
>>>c = np.sin(b)
# c 使用了关键字参数 sin_array
>>>np.savez('test.npz', a, b, sin_array=c)
>>>d = np.load('test.npz')
# 查看各个数组名称
>>>print(d.files)
['sin_array', 'arr_0', 'arr_1']
# 查看数组
>>>print(d['arr_0'])
[1 2 3 4 5]
>>>print(d['arr_1'])
[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]
>>>print(d['sin_array'])
[0.         0.09983342 0.19866933 0.29552021 0.38941834 0.47942554
 0.56464247 0.64421769 0.71735609 0.78332691]
```

#### numpy.savetxt()

`savetxt()` 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。

```python
np.loadtxt(FILENAME, dtype=int, delimiter=' ')
np.savetxt(FILENAME, a, fmt="%d", delimiter=",")
```

参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。

```python
>>>np.savetxt('student.txt', a, fmt='%s')
>>>e = np.loadtxt('student.txt', dtype=student)
>>>e
array([('amos', 24, 100), ('anna', 20, 101)],
      dtype=[('name', '<U20'), ('age', '<i4'), ('marks', '<i4')])
# 使用delimiter参数
>>>np.savetxt('text.txt', f, fmt='%d', delimiter=',')
>>>g = np.loadtxt('text.txt', delimiter=',')
>>>g
array([[0., 0., 1., 1., 2.],
       [2., 3., 3., 4., 4.],
       [5., 5., 6., 6., 7.],
       [7., 8., 8., 9., 9.]])
```

> 以上3.11.1部分节选自[runoob.com](https://www.runoob.com/numpy/numpy-io.html)。

### 3.11.2 读写文件中的列表形式数据

要读写文本格式的数据(如TXT或CSV)，可以使用`numpy.genfromtxt()`

> id,value1,value2,value3
> 1,123,1.4,23
> 2,,0.5,18
> 3,,2.1,19

```python
>>>data_test = np.genfromtxt('test.csv', delimiter=',', names=True)
>>>data_test
array([(1., 123., 1.4, 23.), (2.,  nan, 0.5, 18.), (3.,  nan, 2.1, 19.)],
      dtype=[('id', '<f8'), ('value1', '<f8'), ('value2', '<f8'), ('value3', '<f8')])
>>>print(data_test['id'])
[1. 2. 3.]
>>>print(data_test[1])
(2., nan, 0.5, 18.)
```